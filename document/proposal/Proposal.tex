\documentclass{article}

\usepackage[margin=1.4in]{geometry}
\usepackage[sorting=none, backend=bibtex]{biblatex}

\addbibresource{Consensus.bib}

\title{Project Proposal \\ for \\ Consensus Protocol Simulator}
\date{October, 2017}
\author{Haobin Ni}

\begin{document}
	\maketitle

	\section{Introduction}
	Distributed consensus has been an active field of study for nearly half a century.	From the classic work of Byzantine agreements \cite{Lamport82} \cite{DolevStrong83}, FLP \cite{FLP85} and DLS \cite{DLS88} lower bounds, to practical protocols such as PBFT \cite{PBFT99}, Paxos \cite{Paxos06} and Raft \cite{Raft14}, including the recent success of Bitcoin \cite{Bitcoin09} and Ethereum \cite{Ethereum14}, the corresponding analysis \cite{Rafael16}, many protocols have been proposed to solve the problem of establishing consensus among honest players despite the influence of corrupted players in a distributed system.
	
    Outside academia, consensus protocols are the key component of data centers/cloud services to provide reliable scalability. This includes well-known examples such as Google Chubby \cite{Chubby06} and Apache Zookeeper \cite{Zookeeper10}.
    
    However, a considerable gap has been observed between the two worlds: On one hand, cryptographers describes their protocols in a very abstract way using frameworks such as universal composition \cite{UC01} because they focus on proving the security properties. On the other hand, system engineers want an exact version of the protocol since they need to make it run on the machines. As consensus protocols can be very subtle, this gap causes many implementations fail to achieve their theoretical correctness \cite{Bugs14} \cite{Bugs16} \cite{Bugs17}. How can one make sure what the engineers have implemented is what the cryptographers have proven?
   
    This project explores one possibility for bridging such a gap - a simulation tool to build/test intermediate representations for consensus protocols. While the representation must be precise to simulate the execution, it also needs to be concise - not adding to much the abstract description of the proposed protocol.
   
    Building such an artifact will not only serve as a starting point towards the synthesis of consensus protocol implementations from its specification but also provides a prototype platform for creating and testing such protocols. Furthermore, it will be a handy pedagogical tool for people to learn and try out consensus protocols.

	\section{Goal}
	
	The goal of this project is to build a simulator which can \textbf{generate the execution path of a protocol with given parameters}. The simulator will have some built-in options for all of the parameters but users can also plugin their custom components without changing the underlying platform/framework. Considering the scope of this course, a list of possible protocol/parameters is followed for reference.
	
	\begin{itemize}
		\item \textbf{Environment}: The environment specify what the protocol needs to do and what the protocol can do.
		\begin{itemize}
			\item Network model: Synchronized or Partially synchronized or Asynchronous
			\item Communication model: Authenticated Channels or PKI
			\item Consensus type: Byzantine agreement, Binary agreement, Linear-ordered log, etc
			\item Other environment parameters: total number of nodes, network delay, random oracle etc
		\end{itemize}
		\item \textbf{Protocol}: The protocol to be simulated. The protocol and the environment should match. e.g. It is not well-defined to run a synchronous protocol in asynchronous network.
		\begin{itemize}
			\item Dolev-Strong Protocol
			\item Herding Protocol
			\item Nakamoto Blockchain
			\item Sleepy Blockchain
		\end{itemize}
		\item \textbf{Adversary}: The user can adopt an adversary program to play the corrupted players to test the guarantees of the protocol.
		\begin{itemize}
			\item Adversary mode: static or adaptive
			\item Adversary type: byzantine, crash, halt
		\end{itemize}
		\item \textbf{Measurement}: The measurement is a function that takes the execution path as input and do various measures, such as consistency, validity and chain quality etc.
	\end{itemize}
	
	Though the above list looks very unwieldy, in the final artifact, there will be some basic UI to make it easier to use. It is also possible to support batch experiments where the user can specify a group of parameter to experiment on.

	\section{Methodology}
	
	This project will be completed in a few fast iterations. A new protocol will be supported in each iteration thus new components must be implemented and necessary changes to the framework will also be made. We will get a running prototype after each iteration and the new insights gained can be tested fairly quickly. Compared to the traditional cascading program paradigm which decides the total design first then carry out the implementation, I think this way of agile development is more suitable for this project since it is more flexible to changes and new ideas.

	\section{Time Table}
	
	Expected Deadline: End of Nov.
	
	\begin{itemize}
		\item Iteration 1: Bootstrap \& Dolev-Strong (- Oct 31)
		\item Iteration 2: More on framework \& Herding Protocol (- Nov 7)
		\item Iteration 3: Nakamoto (- Nov 18)
		\item Iteration 4: Sleepy (- Nov 25)
		\item Wrap-up and final report: (- Nov 29)
	\end{itemize}
	
	\section{Future Works}
	
	This project can be extended further in multiple ways. Here're three of possiblie directions to explore.
	
	\begin{enumerate}
		\item \textbf{Support more protocols}: Extend the framework and implement more protocols. This will make the simulator more powerful in describing protocols.
		\item \textbf{A domain specific language for protocols}: This simulator is in fact somewhere between the ideal world and the real world since it can simulate "an honest third party" or ideal cryptography. So from the interfaces of this simulator we can probably generalize a language to describe the protocols. This description can be very useful since it has a decent amount of abstract. I can see applications in both synthesizing the protocol from specifications and building formal proofs for the protocols.
		\item \textbf{Composition of the protocols}: In the current design of the protocol, composability of the protocols are limited. Idealized cryptography components are treated as blackbox functions but they are built-in and one cannot call other protocols to compose larger protocols. This is a meaningful direction to explore since we want similar composability as we have seen in theory. I believe it is possible to add another level of abstract and somehow "compile" the protocol before it actually runs.
	\end{enumerate}

	\printbibliography

\end{document}
